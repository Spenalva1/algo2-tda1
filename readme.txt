Se entrega la implementacion del TDA (tipo de dato abstracto) lista, el cual también podra ser utilizado como una pila o una cola.

Compilacion: 
    gcc *.c -o lista_se -g -std=c99 -Wall -Wconversion -Wtype-limits -pedantic -Werror -O0

Ejecucion:
    ./lista_se

Ejecucion con valgrind:
    valgrind --leak-check=full --track-origins=yes --show-reachable=yes ./lista_se

Se realizó la implementación de todos los métodos necesarios para poder gestionar elementos mediante el uso del tda lista. cada posición de la lista consiste en una estructura llamada nodo que guarda un puntero al dato que quiera almacenar el usuario y otro puntero al siguiente elemento de la lista. De esta manera se pueden recorrer todos los elementos de la lista. La estructura lista almacena un puntero al primer nodo de la lista y otro puntero al ultimo de ella y también almacena la cantidad de elemntos que posee. Para comenzar a utilizarla la lista debe ser creada mediante el método lista_crear(lista). Luego se podrán insertar datos en cualquier posición de la lista al igual que acceder a los mismos o borrarlos. Cuando la lista ya no sirve puede liberarse la memoria que ocupa mediante el médoto lista_destruir(lista). La razón por la cual se utilizan nodos es para que al guardar cada elemento en el heap, no sea necesario guardar los elementos en posiciones contiguas. Si usaramos vectores habria que hacer un realloc cada vez que se inserten o borren elementos de la lista y tomaria mas tiempo y podria generar errores por lo que utilizando nodos se evitan dichos problemas. 
Esta implementación posee también los métodos necesarios para utilizar la lista como si fuese una pila, podiendo aplilar y desapilar elementos, asi como tambien una cola, encolando y desencolando.
Se ofrece un tda extra llamado iterador el cual permite al usuario iterar sobre todos los elementos de la lista utilizando metodos que permiten que el iterador devuelva el elemento al cual apunta y que éste avance al siguiente elemento.
Por ultimo tambien hay un metodo el cual cumple la función de iterador interno, el cual recibe un puntero a lista y otro a una función y se encarga de ejecutar dicha funcion con cada elemento de la lista.

Una lista es una colección de elementos ordenados. Los punteros a los elementos que se quieren guardar son almacenados en una estrucura llamada nodo y todos los nodos pertenecientes a la lista están conectados mediante punteros que apuntan unos a otros. Por un lado, si la lista es simplemente enlazada, los nodos apuntan al siguiente de la lista. Por otro lado, se dice que la lista es doblemente enlazada cuando cada nodo almacena un puntero para el nodo siguiente y otro para el nodo anterior. En el primer caso solo se puede recorrer la lista en un sentido mientras en en el segundo caso se puede hacer en ambos sentidos.

Las caracteristicas fundamentales de una pila y una cola es el orden con el cual se quitan los elementos previamente insertados. En en caso de la pila, se insertan los elementos por un extremo de la coleccion y luego, cuando se quieran quitar los elementos, lo primeros en ser quitados serán los últimos que hayan sido insertados. Esta forma de operar se llama LIFO (last in first out). En una pila a la inserción se le llama aplilar y al borrar, desapilar.
Por otro lado, en una cola, también se insertan los elementos por un extremo pero luego, a la hora de borrar elementos, se quitan por el otro extremo. Por ello los elementos que hayan sido insertados primero, serán los primeros en ser borrados. Esta manera de operar se denomina FIFO (first in first out). Al método insertar se denomina encolar y al borrado, desencolar.

Un iterador es un TDA externo a la lista que le permite al usuario recorrer cada elemento de una lista. A la hora de la creacion de un iterador, se le asigna una lista la cual recorrerá. El iterador comienza apntando al primer elemento de la lista para luego avanzar hacia los demas. El iterador irá apuntando a cada elemento de la lista y el usuario podrá acceder al elemento apuntado por él. Mediante un método el usuario se encargará de hacer avanzar al iterador al próximo elemento de la lista. Para saber cuando se termino de recorrer la lista existe otro método para que el usuario sepa si todavía quedan elementos por recorrer.

Existe otra manera de iterar por todos los elementos de la lista llamado iterador interno que es distinto al iterador previamente explicado, denominado iterador externo. La principal diferencia entre un interno y un externo es que el segundo se trata de un TDA fuera de la lista, por lo que el usuario será quien lo manipulará, mientras el interno es un procedimiento propio de la lista. Otra diferencia importantes es que en el externo el usuario se encarga de hacer avanzar al iterador avazar por cada elemento y de acceder al elemento apuntado. En uno interno, el usuario llama al metodo de la lista pasandole un puntero a una funcion y la lista se encargará internamente de iterar (mediante un for o while, por ejemplo) ejecutando la función recibida pasándole por parametro cada elemento.